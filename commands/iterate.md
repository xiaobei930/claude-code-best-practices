---
description: 自主迭代循环，自动完成任务序列
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, TodoWrite, Task, WebSearch, WebFetch, Skill, mcp__*
---

# /iterate - 自主迭代循环

> **核心规则**: 任务完成后 **立即** 开始下一个任务，**禁止** 输出总结后等待用户。

单 session 内的自主开发循环。适合日常开发，在上下文窗口允许的范围内连续完成多个任务。

> 💡 需要长时间运行（小时级）？请直接使用 `/cc-best:cc-ralph` 命令，参考 `.claude/ralph-prompts/` 下的模板。

---

## 核心流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    自主迭代循环                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  读取 progress.md → 选取任务 → 执行 → 验证 → 提交 → 更新文档     │
│         ↑                                              │        │
│         └──────────────────────────────────────────────┘        │
│                       自动继续下一任务                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**立即开始执行：**

1. 读取 `memory-bank/progress.md`
2. 确定当前任务
3. 按下方流程执行

---

## 执行流程

### Step 0: 检查运行模式

读取 `memory-bank/config.json`（如不存在，默认 `full` 模式）：

| 模式   | 管线                            | 适用场景         |
| ------ | ------------------------------- | ---------------- |
| `full` | PM → Lead → Designer → Dev → QA | 完整项目开发     |
| `lite` | Dev → Verify → Commit           | 快速编码、小改动 |

**Lite 模式**: 跳过 Step 1 的角色判断，直接进入 Dev：

- 无需求文档 → 直接 `/cc-best:dev`
- 完成后 → `/cc-best:verify` → `/cc-best:commit` → 下一任务
- 不执行 PM、Lead、Designer、QA 角色
- 适合已有明确需求的快速编码场景

> 切换模式: `/cc-best:setup --interactive` 或直接编辑 `memory-bank/config.json`

**Full 模式**: 按 Step 1 的角色判断表执行完整管线。

---

### Step 1: 确定角色

| 当前状态                            | 选择角色                | 动作                                         |
| ----------------------------------- | ----------------------- | -------------------------------------------- |
| 无需求文档                          | `/cc-best:pm`           | 需求分析                                     |
| REQ 有待澄清项（≥1 个低置信度决策） | `/cc-best:clarify`      | 需求澄清                                     |
| 有需求无设计                        | `/cc-best:lead`         | 技术设计                                     |
| 有设计，前端任务未设计              | `/cc-best:designer`     | UI 设计指导                                  |
| 有任务待开发                        | `/cc-best:dev`          | 编码实现                                     |
| 有代码待验证                        | `/cc-best:verify`       | 综合验证（构建+类型+Lint+测试+安全）         |
| 验证通过，待功能验收                | `/cc-best:qa`           | 功能验收                                     |
| QA 发现实现 Bug（fix_count < 3）    | `/cc-best:dev --bugfix` | 修复后重新 `/cc-best:verify` → `/cc-best:qa` |
| QA 修复循环达上限（fix_count >= 3） | `/cc-best:lead`         | 🛑 熔断，重新评审技术方案                    |
| QA 发现高影响需求假设错误           | `/cc-best:pm`           | 重新评审需求假设                             |

### Step 2: 执行任务

```
角色命令执行
  ├─ /cc-best:dev: 编码实现 + 单元测试
  ├─ /cc-best:verify: 构建 + 类型 + Lint + 测试 + 安全扫描
  ├─ /cc-best:qa: 功能验收 + E2E 测试
  └─ 前端：浏览器验证（Playwright 截图）
```

### Step 3: 完成任务

```
/cc-best:commit → 更新 progress.md → 读取下一任务 → 立即执行
```

**不要停下来！继续下一个任务。**

---

## 禁止行为

```
❌ 禁止：
   "任务已完成，需要我继续吗？"
   "当前状态如下...（等待用户响应）"
   "接下来您想做什么？"

✅ 正确：
   任务完成 → 更新文档 → 读取下一任务 → 立即执行
```

---

## 停止条件

**只有以下情况才能停止**：

1. ✅ 所有任务完成
2. ✅ 用户主动中断（Ctrl+C / Escape）
3. ✅ 遇到无法自动解决的致命错误
4. ✅ 需要用户决策的外部依赖
5. ✅ 上下文需要压缩（自动保存后输出 `/clear` 指令，等待用户执行）
6. ✅ QA↔Dev 修复循环达到 3 次上限（熔断保护）

---

## 置信度检查（可选）

每完成 3 个任务或阶段切换时，可执行 `/cc-best:confidence-check` 评估当前状态：

```
完成 TSK-001 → 完成 TSK-002 → 完成 TSK-003 → /cc-best:confidence-check → 继续
                                               ↑ 每 3 个任务可选执行一次
```

**注意**：这是可选步骤，不在每次编辑后执行。只在以下时机使用：

- 管线阶段切换（PM→Lead, Lead→Dev, Dev→QA）
- 每完成 3 个任务后
- 感觉不确定时

---

## 上下文自动压缩

> **原则**: 自动完成所有准备工作，将用户操作缩减到最少。

### 触发条件（满足任一）

| 信号      | 条件                | 说明                        |
| --------- | ------------------- | --------------------------- |
| 任务计数  | 每完成 **3 个任务** | 主动评估是否需要压缩        |
| Hook 提醒 | 工具调用 ≥ 40 次    | suggest-compact.js 输出警告 |
| 系统提示  | 上下文使用率 > 70%  | Claude Code 内置提示        |

### 自动压缩流程

```
触发条件满足
    ↓
① 自动保存: 更新 progress.md（当前任务状态 + 下一步）
    ↓
② 自动提交: 如有未提交变更，执行 /cc-best:commit
    ↓
③ 生成摘要: 创建 _compact_summary.md
    ↓
④ 输出指令（唯一需要用户操作的步骤）:

   ┌─────────────────────────────────────────┐
   │ 🔄 上下文已自动保存，请执行：            │
   │                                          │
   │   /clear                                 │
   │                                          │
   │ 然后输入：                                │
   │                                          │
   │   /cc-best:catchup && /cc-best:iterate   │
   └─────────────────────────────────────────┘
```

### 与之前行为的区别

| 维度     | 旧行为（等待）                    | 新行为（自动）                      |
| -------- | --------------------------------- | ----------------------------------- |
| 状态保存 | 手动执行 compact-context          | **自动**保存 progress.md + 提交     |
| 摘要生成 | 手动执行 compact-context          | **自动**生成 \_compact_summary.md   |
| 用户操作 | 3 步（compact + clear + catchup） | **1 步**（clear → catchup+iterate） |
| 等待策略 | 停下来问用户"要不要压缩"          | **自动完成后**给出明确指令          |

### 任务计数评估逻辑

每完成 3 个任务时，评估是否需要压缩：

```
完成第 3/6/9/... 个任务后:
├─ 对话较短（工具调用 < 30 次）→ 继续，不压缩
├─ 对话较长（工具调用 ≥ 30 次）→ 执行自动压缩流程
└─ 系统已提示上下文不足 → 立即执行自动压缩流程
```

> ⚠️ **重要**: 官方 auto-compact 有已知 bug（[#18211](https://github.com/anthropics/claude-code/issues/18211)），
> 当上下文超过 ~85% 时压缩可能失败。因此在 **70%** 前就应触发压缩。

---

## 文档更新

每个任务完成后必须更新 `memory-bank/progress.md`：

```markdown
## 当前状态

- **Phase**: Phase 2 - US-1 实现
- **当前任务**: TSK-004 (已完成)
- **下一任务**: TSK-005

## 已完成

- [x] TSK-004: API 接口 - 2025-01-22

## 进行中

- [ ] TSK-005: 前端页面
```

---

## 与 /cc-best:pair 的区别

| 对比项   | `/cc-best:iterate` | `/cc-best:pair`      |
| -------- | ------------------ | -------------------- |
| 自主程度 | 完全自主           | 人机协作             |
| 用户参与 | 仅在阻塞时         | 每步确认             |
| 适用场景 | 明确任务的批量执行 | 学习、讨论、敏感操作 |

> **记住**: 自主迭代的核心是"完成即继续"——不要停下来总结等待，直到所有任务完成或遇到阻塞。
