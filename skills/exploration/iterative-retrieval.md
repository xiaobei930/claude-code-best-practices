# 渐进式上下文检索开发模式

`exploration` 的子策略，适用于复杂的多轮迭代探索。

本技能用于解决复杂代码库探索时的上下文不足问题，通过多轮迭代逐步精炼搜索。

## 核心问题

单次搜索常见问题：

- 搜索范围过大，结果噪音多
- 搜索范围过小，遗漏关键信息
- 命名不一致，找不到相关代码
- 跨模块依赖，单点搜索不完整

## 解决方案：迭代检索循环

```
┌─────────────────────────────────────────────────────────────┐
│                    渐进式检索循环                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   DISPATCH ──→ EVALUATE ──→ REFINE ──→ DISPATCH            │
│      派发        评估        精炼        继续               │
│        │                                   │                │
│        └───────────────────────────────────┘                │
│                    循环直到足够                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 四阶段方法

### Phase 1: DISPATCH（派发初始搜索）

**目标**：建立初始上下文地图

```markdown
1. 分析问题，确定搜索入口点
2. 设计 2-3 个不同角度的搜索：
   - 按文件名模式 (Glob)
   - 按代码内容 (Grep)
   - 按目录结构 (Read)
3. 并行执行搜索
```

**示例**：

```
问题：理解用户认证流程

搜索策略：
1. Glob: **/auth/**/*.ts, **/login/**/*.ts
2. Grep: "authenticate", "verifyToken", "session"
3. Read: src/middleware.ts（入口点）
```

### Phase 2: EVALUATE（评估结果质量）

**目标**：判断当前上下文是否足够

评估清单：

| 检查项         | 状态 | 说明               |
| -------------- | ---- | ------------------ |
| 找到入口点     | ✅❌ | 请求从哪里开始？   |
| 找到核心逻辑   | ✅❌ | 主要处理在哪里？   |
| 找到数据流     | ✅❌ | 数据如何流转？     |
| 找到依赖关系   | ✅❌ | 依赖哪些模块？     |
| 找到配置/常量  | ✅❌ | 有哪些配置项？     |
| **置信度评分** | 0-1  | 是否足够回答问题？ |

**决策规则**：

```
置信度 >= 0.8  →  停止，输出结果
置信度 < 0.8   →  继续 REFINE 阶段
迭代次数 > 5   →  强制停止，输出当前最佳
```

### Phase 3: REFINE（精炼搜索策略）

**目标**：基于评估结果调整搜索

精炼策略：

| 评估结果   | 精炼动作                 |
| ---------- | ------------------------ |
| 结果过多   | 添加更具体的过滤条件     |
| 结果过少   | 放宽搜索条件，尝试同义词 |
| 找到线索   | 沿着线索深入，追踪调用链 |
| 发现新入口 | 添加新的搜索方向         |
| 命名不一致 | 搜索相关的 import/export |

**示例**：

```markdown
评估结果：找到 authMiddleware，但缺少 Token 验证逻辑

精炼策略：

1. 追踪：authMiddleware 内部调用了什么？
2. 搜索：Grep "jwt", "verify", "decode"
3. 读取：authMiddleware 引用的模块
```

### Phase 4: LOOP（循环或完成）

**循环条件**：

```
继续循环 IF:
  - 置信度 < 0.8
  - 迭代次数 < 5
  - 新搜索有明确目标

停止循环 IF:
  - 置信度 >= 0.8
  - 迭代次数 >= 5
  - 无新的搜索方向
```

---

## 实践示例

### 场景：理解订单处理流程

```markdown
## 迭代 1：初始派发

搜索：

- Glob: **/order/**/\*.ts
- Grep: "createOrder", "processOrder"

结果：找到 5 个文件
置信度：0.3（只找到入口，缺少流程细节）

## 迭代 2：精炼

发现：OrderService.create() 调用了多个子服务
新搜索：

- Read: OrderService.ts
- Grep: "InventoryService", "PaymentService"

结果：找到服务调用链
置信度：0.5（找到调用关系，缺少错误处理）

## 迭代 3：深入

发现：有 OrderStateMachine 管理状态
新搜索：

- Grep: "OrderStateMachine", "OrderStatus"
- Read: order/state-machine.ts

结果：完整状态流转图
置信度：0.85（足够理解流程）

## 停止，输出结果
```

---

## 与其他技能的配合

| 场景          | 推荐组合                                |
| ------------- | --------------------------------------- |
| 复杂 Bug 调试 | iterative-retrieval → debug             |
| 架构分析      | iterative-retrieval → isolated-research |
| 新功能实现    | iterative-retrieval → lead              |
| 安全审查      | iterative-retrieval → security          |

---

## 输出格式

```markdown
## 检索报告

### 问题

[原始问题描述]

### 迭代过程

| 迭代 | 搜索策略 | 发现 | 置信度 |
| ---- | -------- | ---- | ------ |
| 1    | ...      | ...  | 0.3    |
| 2    | ...      | ...  | 0.6    |
| 3    | ...      | ...  | 0.85   |

### 关键文件

- `path/file.ts:line` - 功能说明

### 结论

[对问题的回答，基于检索到的上下文]

### 知识图谱

[可选：模块依赖关系、调用链等]
```

---

## 最佳实践

1. **先广后深** - 初始搜索覆盖面广，后续迭代针对性深入
2. **记录线索** - 每次搜索记录发现的新线索
3. **交叉验证** - 用不同搜索方式验证发现
4. **控制迭代** - 设置上限，避免无限循环
5. **输出透明** - 记录每次迭代的决策依据

---

**核心理念**：不要期望一次搜索找到全部答案，通过有策略的迭代逐步构建完整上下文。
